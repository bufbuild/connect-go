// Code generated by protoc-gen-go-rerpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-rerpc v0.0.1
// - protoc              v3.17.3
// source: grpc/reflection/v1alpha/reflection.proto

package reflectionv1alpha1

import (
	context "context"
	errors "errors"
	rerpc "github.com/rerpc/rerpc"
	clientstream "github.com/rerpc/rerpc/clientstream"
	protobuf "github.com/rerpc/rerpc/codec/protobuf"
	handlerstream "github.com/rerpc/rerpc/handlerstream"
	v1alpha "github.com/rerpc/rerpc/internal/gen/proto/go/grpc/reflection/v1alpha"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the
// rerpc package are compatible. If you get a compiler error that this constant
// isn't defined, this code was generated with a version of rerpc newer than the
// one compiled into your binary. You can fix the problem by either regenerating
// this code with an older version of rerpc or updating the rerpc version
// compiled into your binary.
const _ = rerpc.SupportsCodeGenV0 // requires reRPC v0.0.1 or later

// WrappedServerReflectionClient is a client for the
// internal.reflection.v1alpha1.ServerReflection service.
//
// It's a simplified wrapper around the full-featured API of
// UnwrappedServerReflectionClient.
type WrappedServerReflectionClient interface {
	// The reflection service is structured as a bidirectional stream, ensuring
	// all related requests go to a single server.
	ServerReflectionInfo(context.Context) *clientstream.Bidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse]
}

// UnwrappedServerReflectionClient is a client for the
// internal.reflection.v1alpha1.ServerReflection service. It's more complex than
// WrappedServerReflectionClient, but it gives callers more fine-grained control
// (e.g., sending and receiving headers).
type UnwrappedServerReflectionClient interface {
	// The reflection service is structured as a bidirectional stream, ensuring
	// all related requests go to a single server.
	ServerReflectionInfo(context.Context) *clientstream.Bidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse]
}

// ServerReflectionClient is a client for the
// internal.reflection.v1alpha1.ServerReflection service.
type ServerReflectionClient struct {
	client unwrappedServerReflectionClient
}

var _ WrappedServerReflectionClient = (*ServerReflectionClient)(nil)

// NewServerReflectionClient constructs a client for the
// internal.reflection.v1alpha1.ServerReflection service. By default, it uses
// the binary protobuf codec.
//
// The URL supplied here should be the base URL for the gRPC server (e.g.,
// https://api.acme.com or https://acme.com/grpc).
func NewServerReflectionClient(baseURL string, doer rerpc.Doer, opts ...rerpc.ClientOption) (*ServerReflectionClient, error) {
	baseURL = strings.TrimRight(baseURL, "/")
	opts = append([]rerpc.ClientOption{
		rerpc.Codec(protobuf.NameBinary, protobuf.NewBinary()),
	}, opts...)
	serverReflectionInfoFunc, err := rerpc.NewClientStream(
		doer,
		rerpc.StreamTypeBidirectional,
		baseURL,
		"internal.reflection.v1alpha1.ServerReflection/ServerReflectionInfo",
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return &ServerReflectionClient{client: unwrappedServerReflectionClient{
		serverReflectionInfo: serverReflectionInfoFunc,
	}}, nil
}

// ServerReflectionInfo calls
// internal.reflection.v1alpha1.ServerReflection.ServerReflectionInfo.
func (c *ServerReflectionClient) ServerReflectionInfo(ctx context.Context) *clientstream.Bidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse] {
	return c.client.ServerReflectionInfo(ctx)
}

// Unwrap exposes the underlying generic client. Use it if you need finer
// control (e.g., sending and receiving headers).
func (c *ServerReflectionClient) Unwrap() UnwrappedServerReflectionClient {
	return &c.client
}

type unwrappedServerReflectionClient struct {
	serverReflectionInfo func(context.Context) (rerpc.Sender, rerpc.Receiver)
}

var _ UnwrappedServerReflectionClient = (*unwrappedServerReflectionClient)(nil)

// ServerReflectionInfo calls
// internal.reflection.v1alpha1.ServerReflection.ServerReflectionInfo.
func (c *unwrappedServerReflectionClient) ServerReflectionInfo(ctx context.Context) *clientstream.Bidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse] {
	sender, receiver := c.serverReflectionInfo(ctx)
	return clientstream.NewBidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse](sender, receiver)
}

// ServerReflection is an implementation of the
// internal.reflection.v1alpha1.ServerReflection service.
//
// When writing your code, you can always implement the complete
// ServerReflection interface. However, if you don't need to work with headers,
// you can instead implement a simpler version of any or all of the unary
// methods. Where available, the simplified signatures are listed in comments.
//
// NewServerReflection first tries to find the simplified version of each
// method, then falls back to the more complex version. If neither is
// implemented, rerpc.NewServeMux will return an error.
type ServerReflection interface {
	// The reflection service is structured as a bidirectional stream, ensuring
	// all related requests go to a single server.
	ServerReflectionInfo(context.Context, *handlerstream.Bidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse]) error
}

// newUnwrappedServerReflection wraps the service implementation in a
// rerpc.Service, which can then be passed to rerpc.NewServeMux.
//
// By default, services support the binary protobuf and JSON codecs.
func newUnwrappedServerReflection(svc ServerReflection, opts ...rerpc.HandlerOption) *rerpc.Service {
	handlers := make([]rerpc.Handler, 0, 1)
	opts = append([]rerpc.HandlerOption{
		rerpc.Codec(protobuf.NameBinary, protobuf.NewBinary()),
		rerpc.Codec(protobuf.NameJSON, protobuf.NewJSON()),
	}, opts...)

	serverReflectionInfo, err := rerpc.NewStreamingHandler(
		rerpc.StreamTypeBidirectional,
		"internal.reflection.v1alpha1.ServerReflection/ServerReflectionInfo", // procedure name
		"internal.reflection.v1alpha1.ServerReflection",                      // reflection name
		func(ctx context.Context, sender rerpc.Sender, receiver rerpc.Receiver) {
			typed := handlerstream.NewBidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse](sender, receiver)
			err := svc.ServerReflectionInfo(ctx, typed)
			_ = receiver.Close()
			if err != nil {
				if _, ok := rerpc.AsError(err); !ok {
					if errors.Is(err, context.Canceled) {
						err = rerpc.Wrap(rerpc.CodeCanceled, err)
					}
					if errors.Is(err, context.DeadlineExceeded) {
						err = rerpc.Wrap(rerpc.CodeDeadlineExceeded, err)
					}
				}
			}
			_ = sender.Close(err)
		},
		opts...,
	)
	if err != nil {
		return rerpc.NewService(nil, err)
	}
	handlers = append(handlers, *serverReflectionInfo)

	return rerpc.NewService(handlers, nil)
}

type pluggableServerReflectionServer struct {
	serverReflectionInfo func(context.Context, *handlerstream.Bidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse]) error
}

func (s *pluggableServerReflectionServer) ServerReflectionInfo(ctx context.Context, stream *handlerstream.Bidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse]) error {
	return s.serverReflectionInfo(ctx, stream)
}

// NewServerReflection wraps the service implementation in a rerpc.Service,
// ready for use with rerpc.NewServeMux. By default, services support the binary
// protobuf and JSON codecs.
//
// The service implementation may mix and match the signatures of
// ServerReflection and the simplified signatures described in its comments. For
// each method, NewServerReflection first tries to find a simplified
// implementation. If a simple implementation isn't available, it falls back to
// the more complex implementation. If neither is available, rerpc.NewServeMux
// will return an error.
//
// Taken together, this approach lets implementations embed
// UnimplementedServerReflection and implement each method using whichever
// signature is most convenient.
func NewServerReflection(svc any, opts ...rerpc.HandlerOption) *rerpc.Service {
	var impl pluggableServerReflectionServer

	// Find an implementation of ServerReflectionInfo
	if serverReflectionInfoer, ok := svc.(interface {
		ServerReflectionInfo(context.Context, *handlerstream.Bidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse]) error
	}); ok {
		impl.serverReflectionInfo = serverReflectionInfoer.ServerReflectionInfo
	} else {
		return rerpc.NewService(nil, errors.New("no ServerReflectionInfo implementation found"))
	}

	return newUnwrappedServerReflection(&impl, opts...)
}

var _ ServerReflection = (*UnimplementedServerReflection)(nil) // verify interface implementation

// UnimplementedServerReflection returns CodeUnimplemented from all methods.
type UnimplementedServerReflection struct{}

func (UnimplementedServerReflection) ServerReflectionInfo(context.Context, *handlerstream.Bidirectional[v1alpha.ServerReflectionRequest, v1alpha.ServerReflectionResponse]) error {
	return rerpc.Errorf(rerpc.CodeUnimplemented, "internal.reflection.v1alpha1.ServerReflection.ServerReflectionInfo isn't implemented")
}
