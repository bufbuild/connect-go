package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/bufconnect/connect"
)

const (
	contextPackage = protogen.GoImportPath("context")
	httpPackage    = protogen.GoImportPath("net/http")
	stringsPackage = protogen.GoImportPath("strings")
	errorsPackage  = protogen.GoImportPath("errors")

	protoPackage = protogen.GoImportPath("google.golang.org/protobuf/proto")

	connectPackage      = protogen.GoImportPath("github.com/bufconnect/connect")
	connectProtoPackage = protogen.GoImportPath("github.com/bufconnect/connect/codec/protobuf")
	cstreamPackage      = protogen.GoImportPath("github.com/bufconnect/connect/clientstream")
	hstreamPackage      = protogen.GoImportPath("github.com/bufconnect/connect/handlerstream")
)

var (
	contextContext          = contextPackage.Ident("Context")
	contextCanceled         = contextPackage.Ident("Canceled")
	contextDeadlineExceeded = contextPackage.Ident("DeadlineExceeded")
	errorsIs                = errorsPackage.Ident("Is")
)

func generate(gen *protogen.Plugin, file *protogen.File, separatePackage bool) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_connect.pb.go"
	var path protogen.GoImportPath
	if !separatePackage {
		path = file.GoImportPath
	}
	g := gen.NewGeneratedFile(filename, path)
	preamble(gen, file, g)
	content(file, g)
	return g
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	out := fmt.Sprintf("v%d.%d.%d", v.GetMajor(), v.GetMinor(), v.GetPatch())
	if s := v.GetSuffix(); s != "" {
		out += "-" + s
	}
	return out
}

func preamble(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	g.P("// Code generated by protoc-gen-go-connect. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-go-connect v", connect.Version)
	g.P("// - protoc              ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		wrap(g, file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

func content(file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}
	handshake(g)
	for _, svc := range file.Services {
		service(file, g, svc)
	}
}

func handshake(g *protogen.GeneratedFile) {
	wrap(g, "This is a compile-time assertion to ensure that this generated file ",
		"and the connect package are compatible. If you get a compiler error that this constant ",
		"isn't defined, this code was generated with a version of connect newer than the one ",
		"compiled into your binary. You can fix the problem by either regenerating this code ",
		"with an older version of connect or updating the connect version compiled into your binary.")
	g.P("const _ = ", connectPackage.Ident("SupportsCodeGenV0"), " // requires connect v0.0.1 or later")
	g.P()
}

type names struct {
	Base string

	SimpleClient       string
	FullClient         string
	ClientConstructor  string
	SimpleClientImpl   string
	FullClientImpl     string
	ClientExposeMethod string

	Server                     string
	UnimplementedServer        string
	FullHandlerConstructor     string
	AdaptiveServerImpl         string
	AdaptiveHandlerConstructor string
}

func newNames(service *protogen.Service) names {
	base := service.GoName
	return names{
		Base: base,

		SimpleClient:       fmt.Sprintf("Wrapped%sClient", base),
		FullClient:         fmt.Sprintf("Unwrapped%sClient", base),
		ClientConstructor:  fmt.Sprintf("New%sClient", base),
		SimpleClientImpl:   fmt.Sprintf("%sClient", base),
		FullClientImpl:     fmt.Sprintf("unwrapped%sClient", base),
		ClientExposeMethod: "Unwrap",

		Server:                     base,
		UnimplementedServer:        fmt.Sprintf("Unimplemented%s", base),
		FullHandlerConstructor:     fmt.Sprintf("newUnwrapped%s", base),
		AdaptiveServerImpl:         fmt.Sprintf("pluggable%sServer", base),
		AdaptiveHandlerConstructor: fmt.Sprintf("New%s", base),
	}
}

func service(file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	names := newNames(service)

	clientInterface(g, service, names, false /* full */)
	clientInterface(g, service, names, true /* full */)
	clientImplementation(g, service, names)

	serverInterface(g, service, names)
	serverConstructor(g, service, names)
	adaptiveServerImplementation(g, service, names)
	adaptiveServerConstructor(g, service, names)
	unimplementedServerImplementation(g, service, names)
}

func clientInterface(g *protogen.GeneratedFile, service *protogen.Service, names names, full bool) {
	var name string
	if full {
		name = names.FullClient
		wrap(g, name, " is a client for the ", service.Desc.FullName(), " service. ",
			"It's more complex than ", names.SimpleClient, ", but it gives callers more ",
			"fine-grained control (e.g., sending and receiving headers).")
	} else {
		name = names.SimpleClient
		wrap(g, name, " is a client for the ", service.Desc.FullName(),
			" service.")
		g.P("//")
		wrap(g, "It's a simplified wrapper around the full-featured API of ", names.FullClient, ".")
	}
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		deprecated(g)
	}
	g.Annotate(name, service.Location)
	g.P("type ", name, " interface {")
	for _, method := range service.Methods {
		g.Annotate(name+"."+method.GoName, method.Location)
		leadingComments(g, method.Comments.Leading, method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated())
		g.P(clientSignature(g, method, false /* named */, full))
	}
	g.P("}")
	g.P()
}

func clientSignature(g *protogen.GeneratedFile, method *protogen.Method, named bool, full bool) string {
	reqName := "req"
	ctxName := "ctx"
	if !named {
		reqName, ctxName = "", ""
	}
	if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
		// bidi streaming
		return method.GoName + "(" + ctxName + " " + g.QualifiedGoIdent(contextContext) + ") " +
			"*" + g.QualifiedGoIdent(cstreamPackage.Ident("Bidirectional")) +
			"[" + g.QualifiedGoIdent(method.Input.GoIdent) + ", " + g.QualifiedGoIdent(method.Output.GoIdent) + "]"
	}
	if method.Desc.IsStreamingClient() {
		// client streaming
		return method.GoName + "(" + ctxName + " " + g.QualifiedGoIdent(contextContext) + ") " +
			"*" + g.QualifiedGoIdent(cstreamPackage.Ident("Client")) +
			"[" + g.QualifiedGoIdent(method.Input.GoIdent) + ", " + g.QualifiedGoIdent(method.Output.GoIdent) + "]"
	}
	if method.Desc.IsStreamingServer() {
		// server streaming
		if full {
			return method.GoName + "(" + ctxName + " " + g.QualifiedGoIdent(contextContext) +
				", " + reqName + " *" + g.QualifiedGoIdent(connectPackage.Ident("Request")) + "[" +
				g.QualifiedGoIdent(method.Input.GoIdent) + "]) " +
				"(*" + g.QualifiedGoIdent(cstreamPackage.Ident("Server")) +
				"[" + g.QualifiedGoIdent(method.Output.GoIdent) + "]" +
				", error)"
		} else {
			return method.GoName + "(" + ctxName + " " + g.QualifiedGoIdent(contextContext) +
				", " + reqName + " *" + g.QualifiedGoIdent(method.Input.GoIdent) + ") " +
				"(*" + g.QualifiedGoIdent(cstreamPackage.Ident("Server")) +
				"[" + g.QualifiedGoIdent(method.Output.GoIdent) + "]" +
				", error)"
		}
	}
	// unary; symmetric so we can re-use server templating
	return method.GoName + serverSignatureParams(g, method, named, full)
}

func procedureName(method *protogen.Method) string {
	return fmt.Sprintf(
		"%s.%s/%s",
		method.Parent.Desc.ParentFile().Package(),
		method.Parent.Desc.Name(),
		method.Desc.Name(),
	)
}

func reflectionName(service *protogen.Service) string {
	return fmt.Sprintf("%s.%s", service.Desc.ParentFile().Package(), service.Desc.Name())
}

func clientImplementation(g *protogen.GeneratedFile, service *protogen.Service, names names) {
	// Client struct.
	clientOption := connectPackage.Ident("ClientOption")
	wrap(g, names.SimpleClientImpl, " is a client for the ", service.Desc.FullName(), " service.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		deprecated(g)
	}
	g.P("type ", names.SimpleClientImpl, " struct {")
	g.P("client ", names.FullClientImpl)
	g.P("}")
	g.P()
	g.P("var _ ", names.SimpleClient, " = (*", names.SimpleClientImpl, ")(nil)")

	// Client constructor.
	wrap(g, names.ClientConstructor, " constructs a client for the ", service.Desc.FullName(),
		" service. By default, it uses the binary protobuf codec.")
	g.P("//")
	wrap(g, "The URL supplied here should be the base URL for the gRPC server ",
		"(e.g., https://api.acme.com or https://acme.com/grpc).")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		deprecated(g)
	}
	g.P("func ", names.ClientConstructor, " (baseURL string, doer ", connectPackage.Ident("Doer"),
		", opts ...", clientOption, ") (*", names.SimpleClientImpl, ", error) {")
	g.P("baseURL = ", stringsPackage.Ident("TrimRight"), `(baseURL, "/")`)
	g.P("opts = append([]", clientOption, "{")
	g.P(connectPackage.Ident("Codec"), "(", connectProtoPackage.Ident("NameBinary"), ", ",
		connectProtoPackage.Ident("NewBinary"), "()),")
	g.P("}, opts...)")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			g.P(unexport(method.GoName), "Func, err := ", connectPackage.Ident("NewClientStream"), "(")
			g.P("doer,")
			if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
				g.P(connectPackage.Ident("StreamTypeBidirectional"), ",")
			} else if method.Desc.IsStreamingClient() {
				g.P(connectPackage.Ident("StreamTypeClient"), ",")
			} else {
				g.P(connectPackage.Ident("StreamTypeServer"), ",")
			}
			g.P("baseURL,")
			g.P(`"`, procedureName(method), `",`)
			g.P("opts...,")
			g.P(")")
		} else {
			g.P(unexport(method.GoName), "Func, err := ", connectPackage.Ident("NewClientFunc"), "[", method.Input.GoIdent, ", ", method.Output.GoIdent, "](")
			g.P("doer,")
			g.P("baseURL,")
			g.P(`"`, procedureName(method), `",`)
			g.P("opts...,")
			g.P(")")
		}
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
	}
	g.P("return &", names.SimpleClientImpl, "{client: ", names.FullClientImpl, "{")
	for _, method := range service.Methods {
		g.P(unexport(method.GoName), ": ", unexport(method.GoName), "Func,")
	}
	g.P("}}, nil")
	g.P("}")
	g.P()
	var hasFullMethod bool
	for _, method := range service.Methods {
		if method.GoName == names.ClientExposeMethod {
			hasFullMethod = true
		}
		clientMethod(g, service, method, names, false /* full */)
	}
	g.P()
	exposeMethod := names.ClientExposeMethod
	if hasFullMethod {
		exposeMethod += "_"
	}
	wrap(g, exposeMethod, " exposes the underlying generic client. Use it if you need",
		" finer control (e.g., sending and receiving headers).")
	if hasFullMethod {
		g.P("//")
		wrap(g, "Because there's a \"", names.ClientExposeMethod,
			"\" method defined on this service, this function has an awkward name.")
	} else {
		g.P("func (c *", names.SimpleClientImpl, ") ", names.ClientExposeMethod, "() ", names.FullClient, "{")
		g.P("return &c.client")
		g.P("}")
	}
	g.P()

	g.P("type ", names.FullClientImpl, " struct {")
	typeSender := connectPackage.Ident("Sender")
	typeReceiver := connectPackage.Ident("Receiver")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
			g.P(unexport(method.GoName), " func(", contextContext, ") (", typeSender, ", ", typeReceiver, ")")
		} else {
			g.P(unexport(method.GoName), " func", serverSignatureParams(g, method, false /* named */, true /* full */))
		}
	}
	g.P("}")
	g.P()
	g.P("var _ ", names.FullClient, " = (*", names.FullClientImpl, ")(nil)")
	g.P()
	for _, method := range service.Methods {
		clientMethod(g, service, method, names, true /* full */)
	}
}

func clientMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method, names names, full bool) {
	receiver := names.SimpleClientImpl
	if full {
		receiver = names.FullClientImpl
	}
	isStreamingClient := method.Desc.IsStreamingClient()
	isStreamingServer := method.Desc.IsStreamingServer()
	wrap(g, method.GoName, " calls ", method.Desc.FullName(), ".")
	if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
		g.P("//")
		deprecated(g)
	}
	g.P("func (c *", receiver, ") ", clientSignature(g, method, true /* named */, full), " {")

	if !full {
		// Simple client delegates to the underlying full client.
		if isStreamingServer && !isStreamingClient {
			// server streaming
			g.P("return c.client.", method.GoName, "(ctx, ", connectPackage.Ident("NewRequest"), "(req))")
		} else if isStreamingServer || isStreamingClient {
			// client and bidi streaming
			g.P("return c.client.", method.GoName, "(ctx)")
		} else {
			// unary
			g.P("res, err := c.client.", method.GoName, "(ctx, ", connectPackage.Ident("NewRequest"), "(req))")
			g.P("if err != nil {")
			g.P("return nil, err")
			g.P("}")
			g.P("return res.Msg, nil")
		}
		g.P("}")
		g.P()
		return
	}

	if isStreamingClient || isStreamingServer {
		g.P("sender, receiver := c.", unexport(method.GoName), "(ctx)")
		if !isStreamingClient && isStreamingServer {
			// server streaming, we need to send the request.
			g.P("if err := sender.Send(req.Msg); err != nil {")
			g.P("_ = sender.Close(err)")
			g.P("_ = receiver.Close()")
			g.P("return nil, err")
			g.P("}")
			g.P("if err := sender.Close(nil); err != nil {")
			g.P("_ = receiver.Close()")
			g.P("return nil, err")
			g.P("}")
			g.P("return ", cstreamPackage.Ident("NewServer"),
				"[", method.Output.GoIdent, "]", "(receiver), nil")
		} else if isStreamingClient && !isStreamingServer {
			// client streaming
			g.P("return ", cstreamPackage.Ident("NewClient"),
				"[", method.Input.GoIdent, ", ", method.Output.GoIdent, "]", "(sender, receiver)")
		} else {
			// bidi streaming
			g.P("return ", cstreamPackage.Ident("NewBidirectional"),
				"[", method.Input.GoIdent, ", ", method.Output.GoIdent, "]", "(sender, receiver)")
		}
	} else {
		g.P("return c.", unexport(method.GoName), "(ctx, req)")
	}
	g.P("}")
	g.P()
}

func serverInterface(g *protogen.GeneratedFile, service *protogen.Service, names names) {
	wrap(g, names.Server, " is an implementation of the ", service.Desc.FullName(), " service.")
	g.P("//")
	wrap(g, "When writing your code, you can always implement the ",
		"complete ", names.Server, " interface. However, if you don't need to work with ",
		"headers, you can instead implement a simpler version of any or all of the ",
		"unary methods. Where available, the simplified signatures are listed in comments.")
	g.P("//")
	wrap(g, names.AdaptiveHandlerConstructor, " first tries to find the simplified ",
		"version of each method, then falls back to the more complex version. If neither is ",
		"implemented, connect.NewServeMux will return an error.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		deprecated(g)
	}
	g.Annotate(names.Server, service.Location)
	g.P("type ", names.Server, " interface {")
	for _, method := range service.Methods {
		serverInterfaceMethodLeadingComments(
			g,
			method,
			method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated(),
		)
		g.Annotate(names.Server+"."+method.GoName, method.Location)
		g.P(serverSignature(g, method, true /* full */))
	}
	g.P("}")
	g.P()
}

func serverSignature(g *protogen.GeneratedFile, method *protogen.Method, full bool) string {
	return method.GoName + serverSignatureParams(g, method, false /* named */, full)
}

func serverSignatureParams(g *protogen.GeneratedFile, method *protogen.Method, named bool, full bool) string {
	ctxName := "ctx "
	reqName := "req "
	streamName := "stream "
	if !named {
		ctxName, reqName, streamName = "", "", ""
	}
	if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
		// bidi streaming
		return "(" + ctxName + g.QualifiedGoIdent(contextContext) + ", " +
			streamName + "*" + g.QualifiedGoIdent(hstreamPackage.Ident("Bidirectional")) +
			"[" + g.QualifiedGoIdent(method.Input.GoIdent) + ", " + g.QualifiedGoIdent(method.Output.GoIdent) + "]" +
			") error"
	}
	if method.Desc.IsStreamingClient() {
		// client streaming
		return "(" + ctxName + g.QualifiedGoIdent(contextContext) + ", " +
			streamName + "*" + g.QualifiedGoIdent(hstreamPackage.Ident("Client")) +
			"[" + g.QualifiedGoIdent(method.Input.GoIdent) + ", " + g.QualifiedGoIdent(method.Output.GoIdent) + "]" +
			") error"
	}
	if method.Desc.IsStreamingServer() {
		// server streaming
		if full {
			return "(" + ctxName + g.QualifiedGoIdent(contextContext) +
				", " + reqName + "*" + g.QualifiedGoIdent(connectPackage.Ident("Request")) + "[" +
				g.QualifiedGoIdent(method.Input.GoIdent) + "], " +
				streamName + "*" + g.QualifiedGoIdent(hstreamPackage.Ident("Server")) +
				"[" + g.QualifiedGoIdent(method.Output.GoIdent) + "]" +
				") error"
		} else {
			return "(" + ctxName + g.QualifiedGoIdent(contextContext) +
				", " + reqName + "*" + g.QualifiedGoIdent(method.Input.GoIdent) +
				", " + streamName + "*" + g.QualifiedGoIdent(hstreamPackage.Ident("Server")) +
				"[" + g.QualifiedGoIdent(method.Output.GoIdent) + "]" +
				") error"
		}
	}
	// unary
	if full {
		return "(" + ctxName + g.QualifiedGoIdent(contextContext) +
			", " + reqName + "*" + g.QualifiedGoIdent(connectPackage.Ident("Request")) + "[" +
			g.QualifiedGoIdent(method.Input.GoIdent) + "]) " +
			"(*" + g.QualifiedGoIdent(connectPackage.Ident("Response")) + "[" +
			g.QualifiedGoIdent(method.Output.GoIdent) + "], error)"
	}
	return "(" + ctxName + g.QualifiedGoIdent(contextContext) +
		", " + reqName + "*" + g.QualifiedGoIdent(method.Input.GoIdent) + ") " +
		"(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
}

func serverConstructor(g *protogen.GeneratedFile, service *protogen.Service, names names) {
	wrap(g, names.FullHandlerConstructor, " wraps the service implementation in a connect.Service,",
		" which can then be passed to connect.NewServeMux.")
	g.P("//")
	wrap(g, "By default, services support the gRPC and gRPC-Web protocols with ",
		"the binary protobuf and JSON codecs.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		deprecated(g)
	}
	handlerOption := connectPackage.Ident("HandlerOption")
	g.P("func ", names.FullHandlerConstructor, "(svc ", names.Server, ", opts ...", handlerOption,
		") *", connectPackage.Ident("Service"), " {")
	g.P("handlers := make([]", connectPackage.Ident("Handler"), ", 0, ", len(service.Methods), ")")
	g.P("opts = append([]", handlerOption, "{")
	g.P(connectPackage.Ident("Codec"), "(", connectProtoPackage.Ident("NameBinary"), ", ", connectProtoPackage.Ident("NewBinary"), "()", "),")
	g.P(connectPackage.Ident("Codec"), "(", connectProtoPackage.Ident("NameJSON"), ", ", connectProtoPackage.Ident("NewJSON"), "()", "),")
	g.P("}, opts...)")
	g.P()
	for _, method := range service.Methods {
		hname := unexport(string(method.Desc.Name()))

		if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
			g.P(hname, ", err := ", connectPackage.Ident("NewStreamingHandler"), "(")
			if method.Desc.IsStreamingServer() && method.Desc.IsStreamingClient() {
				g.P(connectPackage.Ident("StreamTypeBidirectional"), ",")
			} else if method.Desc.IsStreamingServer() {
				g.P(connectPackage.Ident("StreamTypeServer"), ",")
			} else {
				g.P(connectPackage.Ident("StreamTypeClient"), ",")
			}
			g.P(`"`, procedureName(method), `", // procedure name`)
			g.P(`"`, reflectionName(service), `", // reflection name`)
			g.P("func(ctx ", contextContext, ", sender ", connectPackage.Ident("Sender"),
				", receiver ", connectPackage.Ident("Receiver"), ") {")
			if method.Desc.IsStreamingServer() && method.Desc.IsStreamingClient() {
				// bidi streaming
				g.P("typed := ", hstreamPackage.Ident("NewBidirectional"),
					"[", method.Input.GoIdent, ", ", method.Output.GoIdent, "]", "(sender, receiver)")
			} else if method.Desc.IsStreamingClient() {
				// client streaming
				g.P("typed := ", hstreamPackage.Ident("NewClient"),
					"[", method.Input.GoIdent, ", ", method.Output.GoIdent, "]", "(sender, receiver)")
			} else {
				// server streaming
				g.P("typed := ", hstreamPackage.Ident("NewServer"),
					"[", method.Output.GoIdent, "]", "(sender)")
			}
			if method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
				g.P("req, err := ", connectPackage.Ident("ReceiveRequest"), "[", method.Input.GoIdent, "]",
					"(receiver)")
				g.P("if err != nil {")
				g.P("_ = receiver.Close()")
				g.P("_ = sender.Close(err)")
				g.P("return")
				g.P("}")
				g.P("if err = receiver.Close(); err != nil {")
				g.P("_ = sender.Close(err)")
				g.P("return")
				g.P("}")
				g.P("err = svc.", method.GoName, "(ctx, req, typed)")
			} else {
				g.P("err := svc.", method.GoName, "(ctx, typed)")
				g.P("_ = receiver.Close()")
			}
			g.P("_ = sender.Close(err)")
			g.P("},")
			g.P("opts...,")
			g.P(")")
		} else {
			g.P(hname, ", err := ", connectPackage.Ident("NewUnaryHandler"), "(")
			g.P(`"`, procedureName(method), `", // procedure name`)
			g.P(`"`, reflectionName(service), `", // reflection name`)
			g.P("svc.", method.GoName, ",")
			g.P("opts...,")
			g.P(")")
		}
		g.P("if err != nil {")
		g.P("return ", connectPackage.Ident("NewService"), "(nil, err)")
		g.P("}")
		g.P("handlers = append(handlers, *", hname, ")")
		g.P()
	}
	g.P("return ", connectPackage.Ident("NewService"), "(handlers, nil)")
	g.P("}")
	g.P()
}

func unimplementedServerImplementation(g *protogen.GeneratedFile, service *protogen.Service, names names) {
	g.P("var _ ", names.Server, " = (*", names.UnimplementedServer, ")(nil) // verify interface implementation")
	g.P()
	wrap(g, names.UnimplementedServer, " returns CodeUnimplemented from all methods.")
	g.P("type ", names.UnimplementedServer, " struct {}")
	g.P()
	for _, method := range service.Methods {
		g.P("func (", names.UnimplementedServer, ") ", serverSignature(g, method, true /* full */), "{")
		if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
			g.P("return ", connectPackage.Ident("Errorf"), "(", connectPackage.Ident("CodeUnimplemented"), `, "`, method.Desc.FullName(), ` isn't implemented")`)
		} else {
			g.P("return nil, ", connectPackage.Ident("Errorf"), "(", connectPackage.Ident("CodeUnimplemented"), `, "`, method.Desc.FullName(), ` isn't implemented")`)
		}
		g.P("}")
		g.P()
	}
	g.P()
}

func adaptiveServerImplementation(g *protogen.GeneratedFile, service *protogen.Service, names names) {
	g.P("type ", names.AdaptiveServerImpl, " struct {")
	for _, method := range service.Methods {
		g.P(unexport(method.GoName), " func", serverSignatureParams(g, method, false /* named */, true /* full */))
	}
	g.P("}")
	g.P()
	for _, method := range service.Methods {
		g.P("func (s *", names.AdaptiveServerImpl, ") ", method.GoName,
			serverSignatureParams(g, method, true /* named */, true /* full */), "{")
		if method.Desc.IsStreamingClient() {
			// client and bidi streaming
			g.P("return s.", unexport(method.GoName), "(ctx, stream)")
		} else if method.Desc.IsStreamingServer() {
			// server streaming
			g.P("return s.", unexport(method.GoName), "(ctx, req, stream)")
		} else {
			// unary
			g.P("return s.", unexport(method.GoName), "(ctx, req)")
		}
		g.P("}")
		g.P()
	}
	g.P()
}

func adaptiveServerConstructor(g *protogen.GeneratedFile, service *protogen.Service, names names) {
	wrap(g, names.AdaptiveHandlerConstructor, " wraps the service implementation in a ",
		"connect.Service, ready for use with connect.NewServeMux. By default, services support the ",
		"gRPC and gRPC-Web protocols with the binary protobuf and JSON codecs.")
	g.P("//")
	wrap(g, "The service implementation may mix and match the signatures of ",
		names.Server, " and the simplified signatures described in its comments. ",
		"For each method, ", names.AdaptiveHandlerConstructor, " first tries to find a ",
		"simplified implementation. If a simple implementation isn't ",
		"available, it falls back to the more complex implementation. If neither is ",
		"available, connect.NewServeMux will return an error.")
	g.P("//")
	wrap(g, "Taken together, this approach lets implementations embed ",
		names.UnimplementedServer, " and implement each method using whichever signature ",
		"is most convenient.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		deprecated(g)
	}
	g.P("func ", names.AdaptiveHandlerConstructor, "(svc any, opts ...", connectPackage.Ident("HandlerOption"),
		") *", connectPackage.Ident("Service"), " {")
	g.P("var impl ", names.AdaptiveServerImpl)
	g.P()
	for _, method := range service.Methods {
		fnamer := unexport(method.GoName) + "er"
		wrap(g, "Find an implementation of ", method.Desc.Name())
		if method.Desc.IsStreamingClient() {
			// client and bidi streaming: no simpler signature available, so we just
			// look for the full version.
			g.P("if ", fnamer, ", ok := svc.(interface{", serverSignature(g, method, false /* full */), "}); ok {")
			g.P("impl.", unexport(method.GoName), " = ", fnamer, ".", method.GoName)
			g.P("} else {")
			g.P("return ", connectPackage.Ident("NewService"), "(nil, ",
				errorsPackage.Ident("New"), `("no `, method.GoName, ` implementation found"))`)
			g.P("}")
			g.P()
			continue
		}
		g.P("if ", fnamer, ", ok := svc.(interface{", serverSignature(g, method, false /* full */), "}); ok {")
		if method.Desc.IsStreamingServer() {
			// server streaming
			g.P("impl.", unexport(method.GoName), " = func",
				serverSignatureParams(g, method, true /* named */, true /* full */), " {")
			g.P("return ", fnamer, ".", method.GoName, "(ctx, req.Msg, stream)")
			g.P("}")
		} else {
			// unary
			g.P("impl.", unexport(method.GoName), " = func",
				serverSignatureParams(g, method, true /* named */, true /* full */), " {")
			g.P("res, err := ", fnamer, ".", method.GoName, "(ctx, req.Msg)")
			g.P("if err != nil {")
			g.P("return nil, err")
			g.P("}")
			g.P("return ", connectPackage.Ident("NewResponse"), "(res), nil")
			g.P("}")
		}
		g.P("} else if ", fnamer, ", ok := svc.(interface{", serverSignature(g, method, true /* full */), "}); ok {")
		g.P("impl.", unexport(method.GoName), " = ", fnamer, ".", method.GoName)
		g.P("} else {")
		g.P("return ", connectPackage.Ident("NewService"), "(nil, ", errorsPackage.Ident("New"), `("no `, method.GoName, ` implementation found"))`)
		g.P("}")
		g.P()
	}
	g.P("return ", names.FullHandlerConstructor, "(&impl, opts...)")
	g.P("}")
	g.P()
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }

func deprecated(g *protogen.GeneratedFile) {
	g.P("// Deprecated: do not use.")
}

func leadingComments(g *protogen.GeneratedFile, comments protogen.Comments, isDeprecated bool) {
	if comments.String() != "" {
		g.P(strings.TrimSpace(comments.String()))
	}
	if isDeprecated {
		if comments.String() != "" {
			g.P("//")
		}
		deprecated(g)
	}
}

func serverInterfaceMethodLeadingComments(g *protogen.GeneratedFile, method *protogen.Method, isDeprecated bool) {
	isUnary := !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer()
	if method.Comments.Leading.String() != "" {
		g.P(strings.TrimSpace(method.Comments.Leading.String()))
	}
	if isUnary {
		if method.Comments.Leading.String() != "" {
			g.P("//")
		}
		g.P("// Can also be implemented in a simplified form: ")
		g.P("// ", serverSignature(g, method, false /* full */))
	}
	if isDeprecated {
		if method.Comments.Leading.String() != "" || isUnary {
			g.P("//")
		}
		deprecated(g)
	}
}
