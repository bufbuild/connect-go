package rerpc

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/rerpc/rerpc/codec"
	"github.com/rerpc/rerpc/codec/protobuf"
	"github.com/rerpc/rerpc/compress"
)

const (
	typeDefaultGRPC = "application/grpc"
	typeGRPCPrefix  = typeDefaultGRPC + "+"
	// gRPC protocol uses "proto" instead of "protobuf"
	grpcNameProto = "proto"
)

var (
	grpcStatusTrailers = []string{"Grpc-Status", "Grpc-Message", "Grpc-Status-Details-Bin"}
)

type handlerCfg struct {
	Compressors      map[string]compress.Compressor
	Codecs           map[string]codec.Codec
	MaxRequestBytes  int64
	Registrar        *Registrar
	Interceptor      Interceptor
	Procedure        string
	RegistrationName string
}

func (c *handlerCfg) Validate() error {
	if _, ok := c.Codecs[""]; ok {
		return errors.New("can't register codec with an empty name")
	}
	if _, ok := c.Compressors[""]; ok {
		return errors.New("can't register compressor with an empty name")
	}
	return nil
}

// A HandlerOption configures a Handler.
//
// In addition to any options grouped in the documentation below, remember that
// Registrars and Options are also valid HandlerOptions.
type HandlerOption interface {
	applyToHandler(*handlerCfg)
}

// A Handler is the server-side implementation of a single RPC defined by a
// protocol buffer service. It's the interface between the reRPC library and
// the code generated by the reRPC protoc plugin; most users won't ever need to
// deal with it directly.
//
// To see an example of how Handler is used in the generated code, see the
// internal/ping/v1test package.
type Handler struct {
	stype StreamType
	// TODO: pull off the config fields we need rather than keeping this whole
	// bag.
	config         handlerCfg
	implementation func(context.Context, Sender, Receiver)
	compressors    roCompressors
	codecs         roCodecs
}

// NewUnaryHandler constructs a Handler. The supplied package, service, and
// method names must be protobuf identifiers. For example, a handler for the
// URL "/acme.foo.v1.FooService/Bar" would have package "acme.foo.v1", service
// "FooService", and method "Bar".
//
// Remember that NewUnaryHandler is usually called from generated code - most
// users won't need to deal with protobuf identifiers directly.
func NewUnaryHandler[Req, Res any](
	procedure, registrationName string,
	implementation func(context.Context, *Request[Req]) (*Response[Res], error),
	opts ...HandlerOption,
) (*Handler, error) {
	cfg := handlerCfg{
		Procedure:        procedure,
		RegistrationName: registrationName,
		Compressors: map[string]compress.Compressor{
			compress.NameGzip: compress.NewGzip(),
		},
		Codecs: make(map[string]codec.Codec),
	}
	for _, opt := range opts {
		opt.applyToHandler(&cfg)
	}
	if err := cfg.Validate(); err != nil {
		return nil, Wrap(CodeInternal, err)
	}
	if reg := cfg.Registrar; reg != nil && cfg.RegistrationName != "" {
		reg.register(cfg.RegistrationName)
	}

	untyped := Func(func(ctx context.Context, req AnyRequest) (AnyResponse, error) {
		typed, ok := req.(*Request[Req])
		if !ok {
			return nil, Errorf(CodeInternal, "unexpected handler request type %T", req)
		}
		return implementation(ctx, typed)
	})
	if ic := cfg.Interceptor; ic != nil {
		untyped = ic.Wrap(untyped)
	}
	streamer := func(ctx context.Context, sender Sender, receiver Receiver) {
		defer receiver.Close()
		if err := ctx.Err(); err != nil {
			// TODO: Factor out repeated context error coding.
			if errors.Is(err, context.Canceled) {
				_ = sender.Close(Wrap(CodeCanceled, err))
				return
			}
			if errors.Is(err, context.DeadlineExceeded) {
				_ = sender.Close(Wrap(CodeDeadlineExceeded, err))
				return
			}
			_ = sender.Close(err) // unreachable per context docs
			return
		}
		req, err := ReceiveRequest[Req](receiver)
		if err != nil {
			_ = sender.Close(err)
			return
		}
		res, err := untyped(ctx, req)
		if err != nil {
			if _, ok := AsError(err); !ok {
				if errors.Is(err, context.Canceled) {
					err = Wrap(CodeCanceled, err)
				}
				if errors.Is(err, context.DeadlineExceeded) {
					err = Wrap(CodeDeadlineExceeded, err)
				}
			}
			_ = sender.Close(err)
			return
		}
		for k, v := range res.Header().raw {
			sender.Header().raw[k] = v
		}
		_ = sender.Close(sender.Send(res.Any()))
	}
	return &Handler{
		stype:          StreamTypeUnary,
		config:         cfg,
		implementation: streamer,
		compressors:    newROCompressors(cfg.Compressors),
		codecs:         newROCodecs(cfg.Codecs),
	}, nil
}

// NewStreamingHandler constructs a Handler. The supplied package, service, and
// method names must be protobuf identifiers. For example, a handler for the
// URL "/acme.foo.v1.FooService/Bar" would have package "acme.foo.v1", service
// "FooService", and method "Bar".
//
// Remember that NewStreamingHandler is usually called from generated code -
// most users won't need to deal with protobuf identifiers directly.
func NewStreamingHandler(
	stype StreamType,
	procedure, registrationName string,
	implementation func(context.Context, Sender, Receiver),
	opts ...HandlerOption,
) (*Handler, error) {
	cfg := handlerCfg{
		Procedure:        procedure,
		RegistrationName: registrationName,
		Compressors: map[string]compress.Compressor{
			compress.NameGzip: compress.NewGzip(),
		},
		Codecs: make(map[string]codec.Codec),
	}
	for _, opt := range opts {
		opt.applyToHandler(&cfg)
	}
	if err := cfg.Validate(); err != nil {
		return nil, Wrap(CodeInternal, err)
	}
	if reg := cfg.Registrar; reg != nil && cfg.RegistrationName != "" {
		reg.register(cfg.RegistrationName)
	}
	return &Handler{
		stype:          stype,
		config:         cfg,
		implementation: implementation,
		compressors:    newROCompressors(cfg.Compressors),
		codecs:         newROCodecs(cfg.Codecs),
	}, nil
}

// ServeHTTP implements http.Handler.
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// We don't need to defer functions  to close the request body or read to
	// EOF: the stream we construct later on already does that, and we only
	// return early when dealing with misbehaving clients. In those cases, it's
	// okay if we can't re-use the connection.
	isBidi := (h.stype & StreamTypeBidirectional) == StreamTypeBidirectional
	if isBidi && r.ProtoMajor < 2 {
		w.WriteHeader(http.StatusHTTPVersionNotSupported)
		io.WriteString(w, "bidirectional streaming requires HTTP/2")
		return
	}
	if r.Method != http.MethodPost {
		// grpc-go returns a 500 here, but interoperability with non-gRPC HTTP
		// clients is better if we return a 405.
		w.Header().Set("Allow", http.MethodPost)
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}
	var clientCodec codec.Codec
	ctype := r.Header.Get("Content-Type")
	if codecName := codecFromContentType(ctype); codecName != "" {
		clientCodec = h.codecs.Get(codecName)
	}
	if clientCodec == nil {
		// grpc-go returns 500, but the spec recommends 415.
		// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests
		w.Header().Set("Accept-Post", acceptPostValue(h.codecs))
		w.WriteHeader(http.StatusUnsupportedMediaType)
		return
	}

	spec := Specification{
		Type:      h.stype,
		Procedure: h.config.Procedure,
		IsServer:  true,
	}

	// We need to parse metadata before entering the interceptor stack, but we'd
	// like to report errors to the client in a format they understand (if
	// possible). We'll collect any such errors here and use them to
	// short-circuit early later on.
	//
	// NB, future refactorings will need to take care to avoid typed nils here.
	var failed *Error

	timeout, err := parseTimeout(r.Header.Get("Grpc-Timeout"))
	if err != nil && err != errNoTimeout {
		// Errors here indicate that the client sent an invalid timeout header, so
		// the error text is safe to send back.
		failed = Wrap(CodeInvalidArgument, err)
	} else if err == nil {
		ctx, cancel := context.WithTimeout(r.Context(), timeout)
		defer cancel()
		r = r.WithContext(ctx)
	} // else err == errNoTimeout, nothing to do

	requestCompression := compress.NameIdentity
	if me := r.Header.Get("Grpc-Encoding"); me != "" && me != compress.NameIdentity {
		// We default to identity, so we only care if the client sends something
		// other than the empty string or compress.NameIdentity.
		if h.compressors.Contains(me) {
			requestCompression = me
		} else if failed == nil {
			// Per https://github.com/grpc/grpc/blob/master/doc/compression.md, we
			// should return CodeUnimplemented and specify acceptable compression(s)
			// (in addition to setting the Grpc-Accept-Encoding header).
			failed = Errorf(
				CodeUnimplemented,
				"unknown compression %q: accepted grpc-encoding values are %v",
				me, h.compressors.Names(),
			)
		}
	}
	// Follow https://github.com/grpc/grpc/blob/master/doc/compression.md.
	// (The grpc-go implementation doesn't read the "grpc-accept-encoding" header
	// and doesn't support compression method asymmetry.)
	responseCompression := requestCompression
	// If we're not already planning to compress the response, check whether the
	// client requested a compression algorithm we support.
	if responseCompression == compress.NameIdentity {
		if mae := r.Header.Get("Grpc-Accept-Encoding"); mae != "" {
			for _, enc := range strings.FieldsFunc(mae, splitOnCommasAndSpaces) {
				if h.compressors.Contains(enc) {
					// We found a mutually supported compression algorithm. Unlike standard
					// HTTP, there's no preference weighting, so can bail out immediately.
					responseCompression = enc
					break
				}
			}
		}
	}

	// We should write any remaining headers here, since: (a) the implementation
	// may write to the body, thereby sending the headers, and (b) interceptors
	// should be able to see this data.
	//
	// Since we know that these header keys are already in canonical form, we can
	// skip the normalization in Header.Set. To avoid allocating re-allocating
	// the same slices over and over, we use pre-allocated globals for the header
	// values.
	w.Header()["Content-Type"] = []string{ctype}
	w.Header()["Grpc-Accept-Encoding"] = []string{h.compressors.Names()}
	w.Header()["Grpc-Encoding"] = []string{responseCompression}
	// Every gRPC response will have these trailers.
	w.Header()["Trailer"] = grpcStatusTrailers

	sf := StreamFunc(func(ctx context.Context) (context.Context, Sender, Receiver) {
		sender, receiver := newHandlerStream(
			spec,
			w,
			r,
			h.config.MaxRequestBytes,
			clientCodec,
			h.codecs.Protobuf(), // for errors
			h.config.Compressors[requestCompression],
			h.config.Compressors[responseCompression],
		)
		return ctx, sender, receiver
	})
	if ic := h.config.Interceptor; ic != nil && h.stype != StreamTypeUnary {
		sf = ic.WrapStream(sf)
	}
	ctx, sender, receiver := sf(r.Context())
	if failed != nil {
		_ = receiver.Close()
		_ = sender.Close(failed)
		return
	}
	h.implementation(ctx, sender, receiver)
}

// Path returns the URL pattern to use when registering this handler. It's used
// by the generated code.
func (h *Handler) Path() string {
	return fmt.Sprintf("/" + h.config.Procedure)
}

func splitOnCommasAndSpaces(c rune) bool {
	return c == ',' || c == ' '
}

func acceptPostValue(codecs roCodecs) string {
	names := codecs.Names()
	for i, n := range names {
		if n == protobuf.NameBinary {
			n = "proto"
		}
		names[i] = "application/grpc+" + n
	}
	names = append(names, "application/grpc")
	return strings.Join(names, ",")
}

func codecFromContentType(ctype string) string {
	if ctype == typeDefaultGRPC {
		// implicitly protobuf
		return protobuf.NameBinary
	}
	if !strings.HasPrefix(ctype, typeGRPCPrefix) {
		return ""
	}
	name := strings.TrimPrefix(ctype, typeGRPCPrefix)
	if name == grpcNameProto {
		// normalize to our "protobuf"
		return protobuf.NameBinary
	}
	return name
}

func contentTypeFromCodecName(n string) string {
	// translate back to gRPC's "proto"
	if n == protobuf.NameBinary {
		n = grpcNameProto
	}
	return typeGRPCPrefix + n
}
